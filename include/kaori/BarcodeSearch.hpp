#ifndef KAORI_VARIABLE_LIBRARY_HPP
#define KAORI_VARIABLE_LIBRARY_HPP

#include "BarcodePool.hpp"
#include "MismatchTrie.hpp"
#include "utils.hpp"

#include <cstddef>
#include <unordered_map>
#include <string>
#include <vector>
#include <array>

/**
 * @file BarcodeSearch.hpp
 *
 * @brief Search for barcode sequences.
 */

namespace kaori {

/** 
 * @cond
 */
template<typename Trie_>
inline void fill_library(const std::vector<const char*>& options, std::unordered_map<std::string, SeqIndex>& exact, Trie_& trie, bool reverse) {
    std::size_t len = trie.length();
    auto nopt = options.size();

    for (decltype(nopt) i = 0; i < nopt; ++i) {
        auto ptr = options[i];

        std::string current;
        if (!reverse) {
            current = std::string(ptr, ptr + len);
        } else {
            current.reserve(len);
            for (size_t j = 0; j < len; ++j) {
                current += complement_base<true, true>(ptr[len - j - 1]);
            }
        }

        // Note that this must be called, even if the sequence is duplicated;
        // otherwise the trie's internal counter will not be properly incremented.
        auto status = trie.add(current.c_str());

        if (!status.has_ambiguous) {
            if (!status.is_duplicate || status.duplicate_replaced) {
                exact[current] = i;
            } else if (status.duplicate_cleared) {
                exact[current] = UNMATCHED;
            }
        }
    }

    trie.optimize();
    return;
}
/** 
 * @endcond
 */

/**
 * @brief Search for known barcode sequences.
 *
 * This supports exact and mismatch-aware searches for known sequences.
 * Mismatches may be distributed anywhere along the length of the sequence, see `AnyMismatches` for details.
 * Instances of this class use caching to avoid redundant work when a mismatching sequence has been previously encountered.
 */
class SimpleBarcodeSearch {
public:
    /**
     * @brief Optional parameters for `SimpleBarcodeSearch`.
     */
    struct Options {
        /**
         * Maximum number of mismatches for any search performed by `SimpleBarcodeSearch::search`.
         */
        SeqLength max_mismatches = 0;

        /** 
         * Whether to reverse-complement the barcode sequences before indexing them.
         */
        bool reverse = false;

        /** 
         * How duplicated barcode sequences should be handled.
         */
        DuplicateAction duplicates = DuplicateAction::ERROR;
    };

public:
    /**
     * Default constructor.
     * This is only provided for composition purposes; methods of this class should only be called on properly constructed instance.
     */
    SimpleBarcodeSearch() = default;

    /**
     * @param barcode_pool Pool of barcode sequences.
     * @param options Optional parameters for the search.
     */
    SimpleBarcodeSearch(const BarcodePool& barcode_pool, const Options& options) : 
        my_trie(barcode_pool.length(), options.duplicates), 
        my_max_mm(options.max_mismatches) 
    {
        fill_library(barcode_pool.pool(), my_exact, my_trie, options.reverse);
    }

private:
    AnyMismatches my_trie;
    SeqLength my_max_mm;
    std::unordered_map<std::string, SeqLength> my_exact;

    struct CacheEntry {
        CacheEntry(SeqIndex index, SeqLength mismatches) : index(index), mismatches(mismatches) {}
        SeqIndex index;
        SeqLength mismatches;
    };
    std::unordered_map<std::string, CacheEntry> my_cache;

public:
    /**
     * @brief State of the search.
     *
     * This contains both the results of `search()` for a given input sequence,
     * as well as cached mismatches to optimize searches for future inputs.
     */
    struct State {
        /**
         * Index of the known sequence that matches best to the input sequence in `search()` (i.e., fewest total mismatches).
         * If no match was found or if the best match is ambiguous, this will be set to `UNMATCHED`.
         */
        SeqIndex index = 0;

        /**
         * Number of mismatches with the matching known sequence.
         * This should only be used if `index` has a value.
         */
        SeqLength mismatches = 0;
        
        /**
         * @cond
         */
        std::unordered_map<std::string, CacheEntry> cache;
        /**
         * @endcond
         */
    };

    /**
     * Initialize the search state for thread-safe execution.
     *
     * @return A new `SeachState()`.
     */
    State initialize() const {
        return State();
    }

    /**
     * Incorporate the mismatch cache from `state` into the cache for this `SimpleBarcodeSearch` instance.
     * This allows regular consolidation of optimizations across threads.
     * On return, the mismatch cache of `state` is combined with that of this instance.
     *
     * @param state A state object generated by `initialize()`.
     * Typically this has already been used in `search()` at least once.
     */
    void reduce(State& state) {
        my_cache.merge(state.cache);
        state.cache.clear();
    }

public:
    /**
     * Search the known sequences in the barcode pool for an input sequence.
     * The number of allowed mismatches is equal to the maximum specified in the constructor.
     * 
     * @param search_seq The input sequence to use for searching.
     * This is expected to have the same length as the known sequences.
     * @param state A state object generated by `initialize()`.
     * On return, `state` is filled with the details of the best-matching barcode sequence, if any exists.
     */
    void search(const std::string& search_seq, State& state) const {
        search(search_seq, state, my_max_mm);
        return;
    }

    /**
     * Search the known sequences in the barcode pool for an input sequence,
     * with potentially more stringent mismatch requirements.
     * This can improve efficiency in situations where some mismatches have already been consumed by matching the template sequence.
     *
     * @param search_seq The input sequence to use for searching.
     * This is expected to have the same length as the known sequences.
     * @param state A state object generated by `initialize()`.
     * On return, `state` is filled with the details of the best-matching barcode sequence, if any exists.
     * @param allowed_mismatches Allowed number of mismatches.
     * This should not be greater than the maximum specified in the constructor.
     */
    void search(const std::string& search_seq, State& state, SeqLength allowed_mismatches) const {
        auto it = my_exact.find(search_seq);
        if (it != my_exact.end()) {
            state.index = it->second;
            state.mismatches = 0;
            return;
        }

        auto set_unmatched = [&]() -> void {
            state.index = UNMATCHED;
            state.mismatches = 0;
        };

        auto set_matched = [&](const CacheEntry& cached) -> void {
            state.index = cached.index;
            state.mismatches = cached.mismatches;
        };

        auto set_from_cache = [&](const CacheEntry& cached) -> void {
            if (cached.mismatches > allowed_mismatches) {
                set_unmatched();
            } else {
                set_matched(cached);
            }
        };

        auto cit = cache.find(x);
        if (cit != cache.end()) {
            set_from_cache(cIt->second);
            return;
        }

        auto lIt = res.cache.find(x);
        if (lIt != res.cache.end()) {
            set_from_cache(lIt->second);
            return;
        }

        auto missed = trie.search(x.c_str(), allowed_mismatches);
        if (is_trie_index_ok(missed.first)) {
            // No need to check the requested number of mismatches, as we explicitly searched for that in the trie.
            CacheEntry cached(missed.first, missed.second);
            set_matched(cached);
            state.cache[x] = std::move(cached);
            return;
        }

        // The trie search breaks early when it hits allowed_mismatches, but
        // allowed_mismatches might be different across calls to search(). If
        // we break early and report a miss, the miss will be cached and
        // returned in cases where there is a higher cap (and thus might
        // actually be a hit). As such, we should only store a miss in the
        // cache when the requested number of mismatches is equal to the
        // maximum number of mismatches that was specified in the constructor.
        if (allowed_mismatches == max_mismatches) {
            state.cache[x] = CacheEntry(UNMATCHED, 0);
        }

        set_unmatched();
    }
};

/**
 * @brief Search for known barcode sequences with segmented mismatches.
 *
 * This supports exact and mismatch-aware searches for known sequences.
 * Mismatches are restricted by segments along the sequence, see `SegmentedMismatches` for details. 
 * Instances of this class use caching to avoid redundant work when a mismatching sequence has been previously encountered.
 *
 * @tparam num_segments_ Number of segments to consider.
 */
template<int num_segments_>
class SegmentedBarcodeSearch {
public:
    /**
     * @brief Optional parameters for a `SegmentedBarcodeSearch`.
     */
    struct Options {
        /**
         * @param max_mismatch_per_segment Maximum number of mismatches per segment.
         * This is used to fill `max_mismatches`.
         */
        Options(SeqLength max_mismatch_per_segment = 0) {
            max_mismatches.fill(max_mismatch_per_segment);
        }
        
        /**
         * Maximum number of mismatches in each segment for `SegmentedBarcodeSearch::search()`.
         * All values should be non-negative.
         * Defaults to an all-zero array in the `Options()` constructor.
         */
        std::array<SeqLength, num_segments_> max_mismatches;

        /** 
         * Whether to reverse-complement the barcode sequences before indexing them.
         * Note that, even if `reverse = true`, the segment lengths in the `SegmentedBarcodeSearch()` constructor and `max_mismatches` are still reported in their order on the forward strand.
         */
        bool reverse = false;

        /** 
         * How duplicated barcode sequences should be handled.
         */
        DuplicateAction duplicates = DuplicateAction::ERROR;
    };

public:
    /**
     * Default constructor.
     */
    SegmentedBarcodeSearch() = default;

    /**
     * @param barcode_pool Pool of barcode sequences.
     * @param segments Size of each segment.
     * All values should be positive and their sum should be equal to the barcode length.
     * @param options Optional parameters.
     */
    SegmentedBarcodeSearch(
        const BarcodePool& barcode_pool, 
        std::array<SeqLength, num_segments_> segments, 
        const Options& options
    ) : 
        trie(
            [&]{
                if (options.reverse) {
                    std::reverse(segments.begin(), segments.end());
                }
                return segments;
            }(),
            options.duplicates
        ), 
        max_mm(
            [&]{
                auto copy = options.max_mismatches;
                if (options.reverse) {
                    std::reverse(copy.begin(), copy.end());
                }
                return copy;
            }()
        )
    {
        if (barcode_pool.length() != trie.length()) {
            throw std::runtime_error("variable sequences should have the same length as the sum of segment lengths");
        }
        fill_library(barcode_pool.pool(), exact, trie, options.reverse);
    }

public:
    /**
     * @brief State of the search.
     *
     * This contains both the results of the search for any given input sequence,
     * as well as cached mismatches to optimize searches for future inputs.
     */
    struct State {
        /**
         * Index of the known sequence that matches best to the input sequence in `search()` (i.e., fewest total mismatches).
         * If no match was found or if the best match is ambiguous, this will be set to `UNMATCHED`.
         */
        SeqIndex index = 0;

        /**
         * Total number of mismatches with the matching known sequence, summed across all segments.
         * This should only be used if `index != UNMATCHED`.
         */
        SeqLength mismatches = 0;

        /**
         * Number of mismatches in each segment.
         * This should only be used if `index != UNMATCHED`.
         */
        std::array<SeqLength, num_segments_> per_segment;
        
        /**
         * @cond
         */
        State() : per_segment() {}

        std::unordered_map<std::string, CacheEntry> cache;
        /**
         * @endcond
         */
    };

    /**
     * Initialize the search state for thread-safe execution.
     *
     * @return A new `SeachState()`.
     */
    State initialize() const {
        return State();
    }

    /**
     * Incorporate the mismatch cache from `state` into the cache for this `SimpleBarcodeSearch` instance.
     * This allows regular consolidation of optimizations across threads.
     * On return, the mismatch cache of `state` is combined with that of this instance.
     *
     * @param state A state object generated by `initialize()`.
     * Typically this has already been used in `search()`.
     */
    void reduce(State& state) {
        cache.merge(state.cache);
        state.cache.clear();
    }

private:
    SegmentedMismatches<num_segments_> my_trie;
    std::array<int, num_segments_> my_max_mm;
    std::unordered_map<std::string, int> my_exact;

    struct CacheEntry {
        CacheEntry(SeqIndex index, SeqLength mismatches, std::array<SeqLength, num_segments_> per_segment) :
            index(index), mismatches(mismatches), per_segment(per_segment) {}
        SeqIndex index;
        SeqLength mismatches;
        std::array<SeqLength, num_segments_> per_segment;
    };
    std::unordered_map<std::string, CacheEntry> cache;

public:
    /**
     * Search the known sequences in the barcode pool for an input sequence.
     * The number of allowed mismatches in each segment is equal to the maximum specified in the constructor.
     * 
     * @param search_seq The input sequence to use for searching.
     * This is expected to have the same length as the known sequences.
     * @param state A state object generated by `initialize()`.
     * On return, `state` is filled with the details of the best-matching barcode sequence, if any exists.
     */
    void search(const std::string& search_seq, State& state) const {
        search(search_seq, state, max_mm);
        return;
    }

    /**
     * Search the known sequences in the barcode pool for an input sequence,
     * with potentially more stringent mismatch requirements for each segment.
     * This can improve efficiency in situations where some mismatches have already been consumed by matching the template sequence.
     *
     * @param search_seq The input sequence to use for searching.
     * This is expected to have the same length as the known sequences.
     * @param state A state object generated by `initialize()`.
     * On return, `state` is filled with the details of the best-matching barcode sequence, if any exists.
     * @param allowed_mismatches Allowed number of mismatches in each segment.
     * Each value should not be greater than the corresponding maximum specified in the constructor.
     */
    void search(const std::string& search_seq, State& state, std::array<int, num_segments_> allowed_mismatches) const {
        auto it = exact.find(search_seq);
        if (it != exact.end()) {
            state.index = it->second;
            state.mismatches = 0;
            std::fill_n(state.per_segment.begin(), num_segments_, 0);
            return;
        }

        auto set_unmatched = [&]() -> void {
            state.index = UNMATCHED;
            state.mismatches = 0;
            std::fill_n(state.per_segment, num_segments_, 0);
        };

        auto set_matched = [&](const CacheEntry& cached) -> void {
            state.index = cached.index;
            state.mismatches = cached.mismatches;
            state.per_segment = cached.per_segments;
        };

        auto set_from_cache = [&](const CacheEntry& cached) -> void {
            for (int s = 0; s < num_segments_; ++s) {
                if (cached.per_segment[s] > allowed_mismatches[s]) {
                    set_unmatched();
                    return;
                }
            }
            set_matched(cached);
        };

        auto cit = cache.find(x);
        if (cit != cache.end()) {
            set_from_cache(cIt->second);
            return;
        }

        auto lIt = res.cache.find(x);
        if (lIt != res.cache.end()) {
            set_from_cache(lIt->second);
            return;
        }

        auto missed = trie.search(x.c_str(), allowed_mismatches);
        if (is_trie_index_ok(missed.first)) {
            // No need to check the requested number of mismatches, as we explicitly searched for that in the trie.
            CacheEntry cached(missed.index, missed.mismatches, missed.per_segment);
            set_matched(cached);
            state.cache[x] = std::move(cached);
            return;
        }

        // The trie search breaks early when it hits allowed_mismatches, but
        // the allowed_mismatches might be different across calls to search().
        // If we break early and report a miss, the miss will be cached and
        // returned in cases where there is a higher cap (and thus might
        // actually be a hit). As such, we should only store a miss in the
        // cache when the requested number of mismatches is equal to the
        // maximum number of mismatches that was specified in the constructor.
        if (allowed_mismatches == my_max_mm) {
            state.cache[x] = CacheEntry(UNMATCHED, 0, {});
        }

        set_unmatched();
    }
};

}

#endif
